---
title: "Code to load cleaned cell-profile data and generate mapping inputs"
---

# Setup
```{r}
#| label: setup

library(data.table)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(httr)
library(glue)

source("bin/outs.R")
```

# Overview 

The cleaned phenotype data is stored in the data cleaning [Github repo]('https://github.com/AndersenLab/2021_GWA_data_cleaning/tree/main/data/processed'). From the cleaned data, we generate mapping inputs for NemaScan. 

This script will pull the trait files from the data cleaning repo for the toxicants analyzed in this study, and format them for NemaScan.

The input format is a file where the rownames represent strain names, and the columns represent the traits to be mapped. The first column is the strain names, and the subsequent columns are the trait values.

# Inputs
```{r}
#| label: inputs

# Path to toxicant metadata file (generated by organize_tox_metadata.qmd)
con_metadata_fn <- "data/processed/tox_data/con_metadata.csv"

# GitHub repo details for downloading trait files
github_repo <- "AndersenLab/2021_GWA_data_cleaning"
github_branch <- "main"
github_traitfiles_path <- "data/processed/traitfiles"

# Expected date prefix in trait file names
date_prefix <- "20230322"

# Path to existing base trait file for comparison
base_traits_fn <- "data/base_toxicant.traits.txt"

# Output path for generated trait file
output_fn <- "data/processed/aggregated_toxicant_traits.tsv"
```

# Load cleaned data

Download the cleaned data stored in the `traitfiles` folder of the data cleaning repo. The trait files are named according to the following convention: `<date>_<trait_name>_traitfile.tsv`, (e.g., `20230322_2_4_D_traitfile.tsv`, or `20230322_Aldicarb_traitfile.tsv`). Each file has three columns: `strain`, `<trait>_length`, `<trait_CV_length>`. 

The folder also contains other data collected for other chemicals not included here. So we filter to just the files that have the toxicant data.

```{r}
#| label: load-toxicant-metadata

# Load condition metadata to identify which toxicants to download
con_metadata <- data.table::fread(con_metadata_fn)

# Extract unique trait names, removing the "length_" prefix to get file name component
trait_info <- con_metadata %>%
  dplyr::select(trait, toxicant) %>%
  dplyr::distinct() %>%
  dplyr::mutate(
    # Remove "length_" prefix to get the trait name used in filenames
    trait_filename = stringr::str_replace(trait, "^length_", ""),
    # Fix decimal point issues: convert underscore before decimal numbers back to period
    # e.g., "Paraquat_62_5" -> "Paraquat_62.5"
    # This handles cases like: Paraquat_62.5, Silver_nitrate_7.8, Triphenyl_phosphate_6.25
    trait_filename = stringr::str_replace(trait_filename, "_(\\d+)_(\\d+)$", "_\\1.\\2"),
    # Construct expected filename
    filename = glue::glue("{date_prefix}_{trait_filename}_traitfile.tsv")
  )

print(glue::glue("Found {nrow(trait_info)} toxicant traits to download"))
print(trait_info)
```

```{r}
#| label: download-trait-files

# Function to download a single trait file from GitHub
download_trait_file <- function(filename, repo = github_repo, branch = github_branch,
                                path = github_traitfiles_path) {
  # Construct raw GitHub URL
  raw_url <- glue::glue("https://raw.githubusercontent.com/{repo}/{branch}/{path}/{filename}")

  message(glue::glue("Downloading: {filename}"))

  # Download file - httr handles authentication via .Renviron or system credentials
  response <- httr::GET(raw_url)

  # Check if download was successful
  if (httr::status_code(response) == 200) {
    # Parse content as text and read as data.table
    content_text <- httr::content(response, "text", encoding = "UTF-8")
    df <- data.table::fread(text = content_text)

    message(glue::glue("  ✓ Successfully downloaded {filename} ({nrow(df)} strains)"))
    return(df)
  } else {
    warning(glue::glue("  ✗ Failed to download {filename}: HTTP {httr::status_code(response)}"))
    return(NULL)
  }
}

# Download all trait files
trait_files_list <- purrr::map(trait_info$filename, download_trait_file)

# Name the list elements with the trait names for easy reference
names(trait_files_list) <- trait_info$trait

# Remove any NULL entries (failed downloads)
trait_files_list <- purrr::compact(trait_files_list)

print(glue::glue("Successfully downloaded {length(trait_files_list)} out of {nrow(trait_info)} trait files"))
```

# Aggregate trait data

Extract only the `<trait>_length` columns from each file and combine into a single wide-format dataframe where strains are rows and traits are columns.

```{r}
#| label: process-and-aggregate

# Function to extract and rename the length column from a trait file
process_trait_file <- function(df, trait_name) {
  # Identify the length column (should match pattern: <something>_length but not CV_length)
  length_col <- names(df)[stringr::str_detect(names(df), "_length$") &
    !stringr::str_detect(names(df), "^CV_")]

  if (length(length_col) == 0) {
    warning(glue::glue("No length column found for trait: {trait_name}"))
    return(NULL)
  }

  if (length(length_col) > 1) {
    warning(glue::glue("Multiple length columns found for trait: {trait_name}, using first"))
    length_col <- length_col[1]
  }

  # Select strain and length column, rename length column to match trait name
  # Note: trait_name should already have the "length_" prefix and underscores instead of periods
  result <- df %>%
    dplyr::select(strain, !!sym(length_col)) %>%
    dplyr::rename(!!trait_name := !!sym(length_col))

  return(result)
}

# Process each trait file
processed_traits <- purrr::imap(trait_files_list, ~ process_trait_file(.x, .y))

# Remove any NULL entries
processed_traits <- purrr::compact(processed_traits)

# Merge all trait dataframes by strain
# Start with the first dataframe
aggregated_traits <- processed_traits[[1]]

# Iteratively left join the remaining dataframes
if (length(processed_traits) > 1) {
  for (i in 2:length(processed_traits)) {
    aggregated_traits <- aggregated_traits %>%
      dplyr::full_join(processed_traits[[i]], by = "strain")
  }
}

print(glue::glue("Aggregated traits data:"))
print(glue::glue("  Strains: {nrow(aggregated_traits)}"))
print(glue::glue("  Traits: {ncol(aggregated_traits) - 1}"))
print(glue::glue("  Columns: {paste(names(aggregated_traits), collapse = ', ')}"))
```

```{r}
#| label: save-aggregated-data

# Save the aggregated trait file
save_tsv(
  data = aggregated_traits,
  output_file = output_fn
)

print(glue::glue("Saved aggregated traits to: {output_fn}"))
```

<!-- # Compare with base trait file

Compare the newly generated trait file with the existing `base_toxicant.traits.txt` to validate that the values match.

```{r}
#| label: load-base-traits

# Load the existing base trait file
base_traits <- data.table::fread(base_traits_fn)

print(glue::glue("Base traits file:"))
print(glue::glue("  Strains: {nrow(base_traits)}"))
print(glue::glue("  Total columns: {ncol(base_traits)}"))

# Identify length columns in base file (exclude CV columns and strain)
base_length_cols <- names(base_traits)[stringr::str_detect(names(base_traits), "^length_")]
print(glue::glue("  Length trait columns: {length(base_length_cols)}"))
```

```{r}
#| label: compare-strains

# Compare strain lists
new_strains <- sort(aggregated_traits$strain)
base_strains <- sort(base_traits$strain)

# Find differences
strains_only_in_new <- setdiff(new_strains, base_strains)
strains_only_in_base <- setdiff(base_strains, new_strains)
strains_in_both <- intersect(new_strains, base_strains)

print(glue::glue("Strain comparison:"))
print(glue::glue("  Strains in both files: {length(strains_in_both)}"))
print(glue::glue("  Strains only in new file: {length(strains_only_in_new)}"))
if (length(strains_only_in_new) > 0) {
  print(glue::glue("    {paste(head(strains_only_in_new, 10), collapse = ', ')}"))
}
print(glue::glue("  Strains only in base file: {length(strains_only_in_base)}"))
if (length(strains_only_in_base) > 0) {
  print(glue::glue("    {paste(head(strains_only_in_base, 10), collapse = ', ')}"))
}
```

```{r}
#| label: compare-traits

# Compare trait columns
new_traits <- sort(names(aggregated_traits)[names(aggregated_traits) != "strain"])
base_traits_names <- sort(base_length_cols)

traits_only_in_new <- setdiff(new_traits, base_traits_names)
traits_only_in_base <- setdiff(base_traits_names, new_traits)
traits_in_both <- intersect(new_traits, base_traits_names)

print(glue::glue("Trait comparison:"))
print(glue::glue("  Traits in both files: {length(traits_in_both)}"))
print(glue::glue("  Traits only in new file: {length(traits_only_in_new)}"))
if (length(traits_only_in_new) > 0) {
  print(glue::glue("    {paste(traits_only_in_new, collapse = ', ')}"))
}
print(glue::glue("  Traits only in base file: {length(traits_only_in_base)}"))
if (length(traits_only_in_base) > 0) {
  print(glue::glue("    {paste(traits_only_in_base, collapse = ', ')}"))
}
```

```{r}
#| label: compare-values

# For overlapping strains and traits, compare the values
if (length(strains_in_both) > 0 && length(traits_in_both) > 0) {
  # Subset both dataframes to common strains and traits
  new_subset <- aggregated_traits %>%
    dplyr::filter(strain %in% strains_in_both) %>%
    dplyr::select(strain, all_of(traits_in_both)) %>%
    dplyr::arrange(strain)

  base_subset <- base_traits %>%
    dplyr::filter(strain %in% strains_in_both) %>%
    dplyr::select(strain, all_of(traits_in_both)) %>%
    dplyr::arrange(strain)

  # Compare values
  # Convert to matrices for comparison (excluding strain column)
  new_matrix <- as.matrix(new_subset[, -1])
  base_matrix <- as.matrix(base_subset[, -1])

  # Calculate differences
  differences <- new_matrix - base_matrix

  # Summary statistics
  max_abs_diff <- max(abs(differences), na.rm = TRUE)
  mean_abs_diff <- mean(abs(differences), na.rm = TRUE)

  # Count perfect matches
  n_total <- length(differences)
  n_both_na <- sum(is.na(new_matrix) & is.na(base_matrix))
  n_matches <- sum(new_matrix == base_matrix, na.rm = TRUE)
  n_diffs <- sum(new_matrix != base_matrix, na.rm = TRUE)

  print(glue::glue("Value comparison for {length(strains_in_both)} strains × {length(traits_in_both)} traits:"))
  print(glue::glue("  Total values compared: {n_total}"))
  print(glue::glue("  Both NA: {n_both_na} ({round(100*n_both_na/n_total, 2)}%)"))
  print(glue::glue("  Perfect matches: {n_matches} ({round(100*n_matches/n_total, 2)}%)"))
  print(glue::glue("  Differences: {n_diffs} ({round(100*n_diffs/n_total, 2)}%)"))
  print(glue::glue("  Maximum absolute difference: {round(max_abs_diff, 6)}"))
  print(glue::glue("  Mean absolute difference: {round(mean_abs_diff, 6)}"))

  # Identify strains/traits with largest differences
  if (n_diffs > 0) {
    diff_df <- data.frame(
      strain = rep(new_subset$strain, times = length(traits_in_both)),
      trait = rep(traits_in_both, each = nrow(new_subset)),
      new_value = as.vector(new_matrix),
      base_value = as.vector(base_matrix),
      difference = as.vector(differences)
    ) %>%
      dplyr::filter(!is.na(difference) & difference != 0) %>%
      dplyr::mutate(abs_diff = abs(difference)) %>%
      dplyr::arrange(desc(abs_diff))

    print(glue::glue("\nTop 10 largest differences:"))
    print(head(diff_df, 10))
  }
} else {
  print("No overlapping strains and traits to compare values")
}
``` -->